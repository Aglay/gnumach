# Makefile for OSKit-Mach microkernel
# Copyright 1997, 1999 Free Software Foundation, Inc.
#
# Permission to use, copy, modify and distribute this software and its
# documentation is hereby granted, provided that both the copyright
# notice and this permission notice appear in all copies of the
# software, derivative works or modified versions, and any portions
# thereof, and that both notices appear in supporting documentation.
#
# THE FREE SOFTWARE FOUNDATION ALLOWS FREE USE OF THIS SOFTWARE IN ITS
# "AS IS" CONDITION.  THE FREE SOFTWARE FOUNDATION DISCLAIMS ANY
# LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE
# USE OF THIS SOFTWARE.




# Variables from `configure'.
srcdir=@srcdir@
systype=@systype@
prefix=@prefix@
tool_prefix=@ac_tool_prefix@

exec_prefix=$(prefix)

bootdir=$(exec_prefix)/boot
includedir=$(prefix)/include
libexecdir=$(exec_prefix)/libexec
bindir=$(exec_prefix)/bin

installed-kernel = $(bootdir)/oskit-mach

sysdep = $(srcdir)/$(systype)

# Programs found by configure.
AWK = @AWK@
INSTALL = @INSTALL@
CC = @CC@
LD = @LD@
NM = @NM@
MIG = @MIG@
MBCHK = @MBCHK@

INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_DATA = @INSTALL_DATA@

CFLAGS = @CFLAGS@
LDFLAGS = @LDFLAGS@

all:

# All the possible architectures
all-archs = i386

all-archs-subdirs = $(patsubst %,$(srcdir)/%/Subdirs,$(all-archs))
all-archs-files = $(patsubst %,$(srcdir)/%/Files,$(all-archs))
all-archs-configures = $(patsubst %,$(srcdir)/%/configure,$(all-archs))

# Files distributed from the top level directory:
topfiles = ChangeLog ChangeLog.0 ChangeLog.00 Drivers.macros Makefile.in \
	README INSTALL config.guess config.sub configure configure.in \
	gensym.awk install-sh version.c NEWS aclocal.m4 COPYING

# All the source in each directory.

# Old crud from a previous configure scheme
bogus-files = bootstrap_symbols.h fast_tas.h hw_footprint.h net_atm.h \
	power_save.h simple_clock.h stat_time.h \
	$(patsubst %,mach_%.h,assert counters debug fixpri host ipc_compat \
	ipc_debug ipc_test kdb ldebug lock_mon machine_routines mp_debug \
	pagemap pcsample ttd vm_debug) \
	$(patsubst %,norma_%.h,device ether ipc task vm)

# Device support interfaces
device-files = \
	       device_init.c dev_pager.c \
	       net_io.c \
	       dev_hdr.h dev_master.h device_port.h \
	       device_types_kernel.h ds_routines.h \
	       memory_object_reply.cli \
	       device_pager.srv device.srv \
	       device_reply.cli device_error_reply.cli
device-cfiles = $(filter %.c,$(device-files))

# IPC implementation
ipc-cfiles = $(addprefix ipc_,$(ipc-names)) \
		mach_msg.c mach_port.c mach_rpc.c mach_debug.c fipc.c
ipc-names = entry.c hash.c init.c kmsg.c marequest.c mqueue.c \
	notify.c object.c port.c pset.c right.c space.c splay.c \
	table.c target.c thread.c
ipc-files = $(ipc-cfiles) mach_port.srv fipc.h port.h mach_msg.h \
	$(patsubst %,ipc_%.h, \
	entry hash init kmsg kmsg_queue machdep marequest mqueue notify \
	object port pset right space splay table target thread types)

# "kernel" implementation (tasks, threads, trivia, etc.)
kern-cfiles = act.c ast.c bootstrap.c counters.c eventcount.c \
	exception.c host.c ipc_host.c ipc_kobject.c ipc_mig.c ipc_sched.c \
	ipc_tt.c kalloc.c lock.c lock_mon.c mach_clock.c mach_factor.c \
	machine.c pc_sample.c priority.c processor.c profile.c \
	queue.c sched_prim.c startup.c syscall_emulation.c \
	syscall_subr.c syscall_sw.c task.c thread.c thread_swap.c \
	time_stamp.c timer.c zalloc.c
kern-files = $(kern-cfiles) \
	act.h assert.h ast.h compat_xxx_defs.h counters.h cpu_number.h \
	debug.h eventcount.h host.h ipc_host.h ipc_kobject.h ipc_sched.h \
	ipc_tt.h kalloc.h kern_types.h lock.h mach_param.h macro_help.h \
	pc_sample.h processor.h queue.h refcount.h sched.h sched_prim.h \
	shuttle.h syscall_emulation.h syscall_subr.h syscall_sw.h \
	task.h thread.h thread_swap.h time_out.h time_stamp.h timer.h \
	zalloc.h \
	mach.srv mach4.srv mach_debug.srv mach_host.srv

# Virtual memory implementation
vm-cfiles = $(addprefix vm_,$(vm-names)) memory_object.c
vm-names = debug.c external.c fault.c init.c kern.c map.c \
	object.c pageout.c resident.c user.c
vm-files = $(vm-cfiles) memory_object_default.cli memory_object_user.cli \
	memory_object.h pmap.h $(patsubst %,vm_%.h, \
	external fault kern map object page pageout user)

# OSKit support files
osenv-overrides = osenv_mem \
		  osenv_log \
		  osenv_irq \
		  osenv_sleep osenv_synch osenv_timer \
		  osenv_bell osenv_softirq
oskit-cfiles = $(osenv-overrides:=.c) \
	       main.c ds_osenv.c ds_request.c ds_routines.c kmsg.c \
	       ds_block.c ds_partition.c \
	       ds_mem.c ds_bus.c \
	       ds_net.c \
	       ds_stream.c \
	       ds_asyncio.c smp-glue.c
oskit-files = $(oskit-cfiles) ds_oskit.h

oskit-dirs-i386 := x86 pc

# Object files that go into the kernel image.  (This will be augmented by the
# machine dependent Makefile fragment.)

# Basic kernel source for Mach
objfiles := $(patsubst %.c,%.o,$(ipc-cfiles) $(kern-cfiles) $(vm-cfiles) \
			       $(device-cfiles) $(oskit-cfiles))
vpath %.c $(addprefix $(srcdir)/,ipc kern vm device oskit \
		                 $(addprefix oskit/,$(oskit-dirs-$(systype))))

# Version number
objfiles += version.o
vpath version.c $(srcdir)


# Header files installed for user use
device-headers= $(addprefix device/,audio_status.h bpf.h device.defs \
		device_reply.defs device_request.defs device_types.defs \
		device_types.h disk_status.h net_status.h tape_status.h \
		tty_status.h)
mach-headers= $(addprefix mach/, bootstrap.defs default_pager.defs \
		default_pager_helper.defs default_pager_types.defs \
		exc.defs mach.defs mach4.defs mach_host.defs mach_norma.defs \
		mach_port.defs mach_types.defs memory_object.defs \
		memory_object_default.defs norma_task.defs notify.defs \
		std_types.defs \
		alert.h boolean.h default_pager_types.h exception.h \
		host_info.h kern_return.h mach_param.h mach_types.h \
		machine.h macro_help.h memory_object.h message.h mig_errors.h \
		msg_type.h norma_special_ports.h notify.h \
		pc_sample.h policy.h port.h processor_info.h \
		profil.h profilparam.h rpc.h std_types.h syscall_sw.h \
		task_info.h task_special_ports.h thread_info.h \
		thread_special_ports.h thread_status.h thread_switch.h \
		time_value.h version.h vm_attributes.h vm_inherit.h \
		vm_param.h vm_prot.h vm_statistics.h inline.h)
mach-debug-headers:= $(addprefix mach_debug/, hash_info.h ipc_info.h \
		mach_debug.defs mach_debug_types.defs mach_debug_types.h \
		pc_info.h vm_info.h zone_info.h)

installed-headers:= $(device-headers) $(mach-headers)

# Other headers for the distribution.  We don't install these, because the
# GNU C library has correct versions for users to use.
other-sys-headers := types.h time.h reboot.h ioctl.h
other-mach-headers := mig_support.h mach_traps.h error.h
other-headers := alloca.h


# Automatically generated source

# User stubs
objfiles += memory_object_user_user.o memory_object_default_user.o \
	    memory_object_reply_user.o \
	    device_reply_user.o device_error_reply_user.o

# Server stubs
objfiles += device_server.o device_pager_server.o mach_port_server.o \
	mach_server.o mach4_server.o mach_debug_server.o mach_host_server.o

# Where to find the relevant Mig source files
vpath %.cli $(srcdir)/vm $(srcdir)/device
vpath %.srv $(srcdir)/device $(srcdir)/ipc $(srcdir)/kern


# We need this symlink in place before we start compiling,
# so <mach/machine/foo.h> headers can be found.
before-compile = mach/machine
mach/machine: mach_machine
	test -d $(@D) || mkdir $(@D)
	rm -f $@
	ln -s ../mach_machine mach/machine
mach_machine:
	rm -f $@
	ln -s $(srcdir)/$(systype)/include/mach/$(systype) mach_machine



#
# Compilation flags
#

DEFINES += -DOSKIT_MACH=1 -DMACH -DMACH_KERNEL -DKERNEL -DCONTINUATIONS @DEFS@
INCLUDES += -I. -I$(srcdir) -I$(srcdir)/include \
	    -I$(srcdir)/bogus -I$(srcdir)/kern -I$(srcdir)/device

include $(sysdep)/Makefrag

CPPFLAGS += $(DEFINES) $(INCLUDES)

MIGFLAGS += $(CPPFLAGS)


# Standard targets

all: kernel

clean:
	rm -f *.[oda] kernel
	rm -f *.symc *.symc.o *_user.c *_server.c
	rm -f $(filter-out config.h,$(wildcard *.h))
	rm -f *.migs_d *.migsh_d *.migu_d *.miguh_d

distclean: clean
	rm -f config.status config.cache config.log config.h Makefile

mostlyclean: distclean

maintainer-clean: mostlyclean
	rm -f $(srcdir)/configure $(all-archs-configures)

check: kernel
	$(MBCHK) $<

#
# Kernel Image
#

# This is the list of routines we decide is OK to steal from the C library.
clib-routines := memcpy memmove memset bcopy bzero memchr rawmemchr \
		 strstr strtok strchr strchrnul strcpy stpcpy strcat \
		 strcmp strncmp \
		 htonl htons ntohl ntohs ffs
magic-symbols := etext edata end


OSKIT_LIBDIR = @OSKIT_LIBDIR@
OSKIT_LIBS = -loskit_kern -loskit_lmm -loskit_com -loskit_smp \
	     -loskit_exec -loskit_unsupp \
	     -loskit_dev -loskit_linux_dev -loskit_diskpart \

# These rules are useful for development, but have significant overhead.
kernel.a: $(objfiles)
	@rm -f $@
	$(AR) cq $@ $^
kernel_nm: kernel.a ; $(NM) -g $< > $@
kernel.a.list: kernel.a; $(AR) t $< | sort > $@
kernel.map.list: kernel.map
	sed -n 's/^kernel\.a(\([^)]*\)).*$$/\1/p' $< | sort > $@
kernel-unused: kernel.a.list kernel.map.list
	(diff -u0 $^ || test $$? -eq 1) | sed -n '1,/@@/d;s/^-//p' > $@
k%nel.o k%nel.map: $(OSKIT_LIBDIR)/multiboot.o $(osenv-overrides:=.o) k%nel.a
	$(CC) $(CFLAGS) -nostdlib -nostartfiles $(LDFLAGS) -r \
	      -o $(@:.map=.o) -Wl,-Map=$(@:.o=.map) \
	      -Wl,-\( $^ -L$(OSKIT_LIBDIR)/.. $(OSKIT_LIBS) -Wl,-\) -lgcc
# This rule has less overhead, but doesn't produce the intermediate
# results necessary to compute `kernel-unused'.
kernel.o: $(OSKIT_LIBDIR)/multiboot.o $(objfiles)
	$(CC) $(CFLAGS) -nostdlib -nostartfiles $(LDFLAGS) -r -o $@ \
	      -Wl,-\( $^ -L$(OSKIT_LIBDIR)/.. $(OSKIT_LIBS) -Wl,-\) -lgcc

%-undef: %.o
	$(NM) -u $< | sed 's/^_*//' | sort -u > $@

kernel-clib: kernel-undef Makefile
	sed -n '$(foreach r,$(clib-routines),/^$r$$/p;)' $< > $@
clib-routines.o: kernel-clib
	$(CC) $(CFLAGS) -nostdlib -nostartfiles $(LDFLAGS) -r -static \
	      -o $@ \
	      `sed 's/^/-Wl,-u,/' $<` -x c /dev/null -lc

oskit-kern%.o: kern%.o clib-routines.o
	$(CC) $(CFLAGS) -nostdlib -nostartfiles $(LDFLAGS) -r -o $@ \
	      -Wl,-\( $^ -L$(OSKIT_LIBDIR)/.. \
			 -loskit_clientos -loskit_c $(OSKIT_LIBS) -Wl,-\) -lgcc

%-undef-bad: %-undef Makefile
	sed '$(foreach r,$(clib-routines) $(magic-symbols),/^$r$$/d;)' $< > $@

kern%: oskit-kern%.o $(OSKIT_LIBDIR)/crtn.o
	$(LD) $(LDFLAGS) $(KERN_LDFLAGS) -o $@ $^

# This combined with the other pattern rules let you ask
# for a target like `kernel-ide+scsi_ncr53c8xx+ethernet_eepro100'
# to link a kernel with a given subset of the oskit drivers.
init-%.c:
	{ echo 'void oskit_linux_init_devs(void) {'; \
	  for drv in $(subst +, ,$*); do \
	    echo "  oskit_linux_init_$${drv} ();"; \
	  done; echo '}'; \
	} > $@T
	mv -f $@T $@

kernel-%.o: $(OSKIT_LIBDIR)/multiboot.o $(objfiles) init-%.o
	$(CC) $(CFLAGS) -nostdlib -nostartfiles $(LDFLAGS) -r -o $@ \
	      -Wl,-\( $^ $(OSKIT_LIBS) -Wl,-\) -lgcc

#
# Installation
#
installed-headers-names = $(addprefix $(includedir)/,$(installed-headers))
installed-sysdep-headers-names = $(addprefix $(includedir)/,$($(systype)-installed-headers))
install: install-headers install-kernel

$(installed-headers-names): $(includedir)/%: $(srcdir)/include/%
	$(INSTALL_DATA) $< $@

$(installed-sysdep-headers-names): $(includedir)/%: $(sysdep)/include/%
	$(INSTALL_DATA) $< $@

install-headers: mkheaderdirs $(installed-headers-names) $(installed-sysdep-headers-names)
	ln -sf $(systype) $(includedir)/mach/machine

install-kernel: kernel mkkerneldirs
	$(INSTALL_PROGRAM) kernel $(installed-kernel)

mkheaderdirs:
	mkdir -p $(includedir) $(includedir)/device $(includedir)/mach \
		$(includedir)/mach/$(systype) $(includedir)/mach/exec

mkkerneldirs:
	mkdir -p $(bootdir)


#
# Building the distribution
#

dist:
	cd $(srcdir) && dpkg-buildpackage



#
# Autoconf support
#
$(srcdir)/configure: $(srcdir)/configure.in
	cd $(srcdir) && autoconf
$(srcdir)/config.h.in: $(srcdir)/acconfig.h
	cd $(srcdir) && autoheader

Makefile: $(srcdir)/Makefile.in config.status
	./config.status
config.h: stamp-configh ;
stamp-configh: $(srcdir)/config.h.in config.status
	./config.status
	touch $@

config.status: $(srcdir)/configure
	./config.status --recheck

vpath %.in $(srcdir)
vpath configure $(srcdir)



#
# How to do some things
#

# Building foo.h from foo.sym:
%.symc: %.sym
	$(AWK) -f $(srcdir)/gensym.awk $< >$*.symc
%.symc.o: %.symc
	$(CC) -S $(CPPFLAGS) $(CFLAGS) $(CPPFLAGS-$@) -x c -o $@ $<
%.h: %.symc.o
	sed <$< -e 's/^[^*].*$$//' | \
		sed -e 's/^[*]/#define/' -e 's/mAgIc[^-0-9]*//' >$@

# Building from foo.cli
%.h %_user.c: %.cli
	$(MIG) $(MIGFLAGS) -header $*.h -user $*_user.c -server /dev/null $<

# Building from foo.srv
%_interface.h %_server.c: %.srv
	$(MIG) $(MIGFLAGS) -header $*_interface.h -server $*_server.c -user /dev/null $<

#
# Dependency generation
#

# Include dependency files
ifneq ($(no_deps),t)

# For each file generated by MiG we need a .d file.
servers = $(filter %_server.o,$(objfiles))
-include $(subst _server.o,.migs_d,$(servers)) /dev/null
-include $(subst _server.o,.migsh_d,$(servers)) /dev/null

# vm_user.o fits the pattern, but is not actually a MiG-related file.
users = $(filter-out vm_user.o,$(filter %_user.o,$(objfiles)))
-include $(subst _user.o,.migu_d,$(users)) /dev/null
-include $(subst _user.o,.miguh_d,$(users)) /dev/null

# For each .o file we need a .d file.
-include $(subst .o,.d,$(filter %.o,$(objfiles))) /dev/null

endif

# Here is how to make those dependency files

%.migs_d: %.srv
	(set -e; $(CPP) $(MIGFLAGS) -M -MG -x c $< | \
	sed -e 's/\.srv\.o:/_server.c $@:/' > $@)

%.migu_d: %.cli
	(set -e; $(CPP) $(MIGFLAGS) -M -MG -x c $< | \
	sed -e 's/\.cli\.o:/_user.c $@:/' > $@)

%.migsh_d: %.migs_d
	sed -e 's/_server\.c /_interface.h /' -e 's/migs_d/migsh_d/' < $< > $@

%.miguh_d: %.migu_d
	sed -e 's/_user\.c /.h /' -e 's/migu_d/miguh_d/' < $< > $@

# Generic rule for $(CC) based compilation for making dependencies
define make-deps
set -e; $(CC) $(CFLAGS) $(CPPFLAGS) -M $< | \
	sed > $@.new -e 's/$*\.o:/$*.o $@:/'
mv -f $@.new $@
endef

%.d: %.c $(before-compile); $(make-deps)
%.d: %.S $(before-compile); $(make-deps)

# .s files don't go through the preprocessor, so we do this
# This rule must come *after* the genuine ones above, so that
# make doesn't build a .s file and then make an empty dependency
# list.
%.d: %.s
	echo '$*.o: $<' > $@
